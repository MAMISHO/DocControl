{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"DocControl","tagline":"Enyo Controller for document objects","body":"DocControl\r\n==========\r\n\r\nDocControl is a controller framework for Enyo. It is heavily \r\ninfluenced by Django Forms, but is designed for a hierarchical \r\ndocument data structure rather than a flat database row. \r\n\r\nSample Application\r\n------------------\r\nA sample application is both (hosted)[./sample.html] and available in the repository.\r\n\r\nAPI\r\n---\r\nThe api is both (hosted)[./api/index.html] and available in the repository.\r\n\r\nBasic Structure\r\n---------------\r\nThree classes (kinds in Enyo parlance) work together to validate your \r\ndata. A `Field` represents the data and performs validation. A `Widget` \r\ndisplays the data by creating enyo components. Finally, a `Field` will \r\nuse one or more `validators`, small reusable snippets of code, to perform \r\nthe actual validation.\r\n\r\nFields can contain other fields, which allows for the validation\r\nof highly nested data. It is possible to create a\r\nsingle DocControl to validate, for example, an entire contact document\r\nincluding an arbitrary number of tagged emails, phone numbers, and \r\nother data.\r\n\r\nThere are currently two types of fields that can contain subfields:\r\n`ContainerField` and `ListField`. A `ContainerField`'s schema defines\r\nmultiple heterogeneous fields, and so is useful for defining a \r\ndocument. A `ListField`'s schema takes a single field (which could be\r\na `ContainerField`). It is used for creating an arbitrary-length array \r\nof identical fields.\r\n\r\nBasic Usage\r\n-----------\r\nThe following will create a simple user field:\r\n\r\n    enyo.kind({ name:\"UserField\", kind: \"ContainerField\", schema: [\r\n        { name: \"username\", \r\n          kind: \"CharField\", \r\n          maxLength: 10, \r\n          minLength: 5, \r\n          widgetAttrs: { \r\n            label: \"Username\", \r\n            helpText: \"CharField between 5 and 10 characters long\", \r\n            initial: \"John Doe\" } },\r\n        { name: \"email\", \r\n          kind: \"EmailField\", \r\n          widgetAttrs: { label: \"Email\", } }\r\n        { name: \"age\", \r\n          kind: \"IntegerField\", \r\n          maxValue: 116, \r\n          minValue: 13, \r\n          widgetAttrs: { \r\n            label: \"Age\", \r\n            helpText: \"Integer between 13 and 116\" } } ],\r\n      widgetAttrs: { \r\n        label: \"Users\", \r\n        helpText: \"Add as many users as you like\" }\r\n    })\r\n\r\n`getClean()` returns the `field`'s data in native javascript \r\nformats. `toJSON()` returns the data in a format suitable for serializing. \r\nboth raise an error if the field is invalid. `isValid()` returns `true` or \r\n`false`. `setValue(val)` to set a `field`'s value.\r\n\r\nIn the default configuration, validation will not occur until you call\r\none of the `UserField`'s `getClean`, `toJSON`, or `isValid` methods. Once one of \r\nthese functions has been called once, validation will run very time data \r\nchanges. You can override this validation behaviour by setting the widget's\r\n`validationStrategy` to another predefined strategy or one written by yourself.\r\n\r\n\r\nInstallation\r\n------------\r\nFirst, download or clone DocControl from github \r\n(https://github.com/dgreisen/DocControl). You can immediately run the\r\nsample application by visiting `sample.html` in a browser. To include \r\nin your project, copy or link the `source` directory into project's lib directory and add a reference to it in your project's `package.js` file.\r\n\r\nDevelopment\r\n-----------\r\nCurrently, validators are written in coffeescript. If you wish to \r\nmodify the existing validators or add more to that file, you will need\r\ncoffeescript. You can easily compile the coffeescript by running:\r\n\r\n    coffee -w -o ./source/ ./coffee/\r\n\r\nin DocControl's root directory.\r\n\r\nTODO\r\n----\r\n1. I would like to remove the coffeescript dependencies for two reasons:\r\n\r\n  a. validators are directly ported from Django, complicating the license\r\n  b. it is silly to require coffeescript to compile one file\r\n2. I hope to convince the Enyo team to make Enyo core compatible with node,\r\n   then you can write a control once for both the front-end and backend.\r\n3. I hope to write a django ./manage.py function that will automatically \r\n   create DocControl schema from django forms, so you don't have to rewrite\r\n   controllers for the front-end.","google":""}